"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _constants = require("./constants");

var _binary = _interopRequireDefault(require("binary"));

var _domain = _interopRequireDefault(require("domain"));

var _net = _interopRequireDefault(require("net"));

// module specific events
var EVENTS = {
  AUTHENTICATION: 'authenticate',
  AUTHENTICATION_ERROR: 'authenticateError',
  CONNECTION_FILTER: 'connectionFilter',
  HANDSHAKE: 'handshake',
  PROXY_CONNECT: 'proxyConnect',
  PROXY_DATA: 'proxyData',
  PROXY_DISCONNECT: 'proxyDisconnect',
  PROXY_END: 'proxyEnd',
  PROXY_ERROR: 'proxyError'
},
    LENGTH_RFC_1928_ATYP = 4;
/**
 * The following RFCs may be useful as background:
 *
 * https://www.ietf.org/rfc/rfc1928.txt - NO_AUTH SOCKS5
 * https://www.ietf.org/rfc/rfc1929.txt - USERNAME/PASSWORD SOCKS5
 *
 **/

var SocksServer = function SocksServer(options) {
  (0, _classCallCheck2["default"])(this, SocksServer);
  var self = this;
  this.activeSessions = [];
  this.options = options || {};
  this.server = _net["default"].createServer(function (socket) {
    socket.on('error', function (err) {
      self.server.emit(EVENTS.PROXY_ERROR, err);
    });
    /**
     * +----+------+----------+------+----------+
     * |VER | ULEN |  UNAME   | PLEN |  PASSWD  |
     * +----+------+----------+------+----------+
     * | 1  |  1   | 1 to 255 |  1   | 1 to 255 |
     * +----+------+----------+------+----------+
     *
     *
     * @param {Buffer} buffer - a buffer
     * @returns {undefined}
     **/

    function authenticate(buffer) {
      var authDomain = _domain["default"].create();

      _binary["default"].stream(buffer).word8('ver').word8('ulen').buffer('uname', 'ulen').word8('plen').buffer('passwd', 'plen').tap(function (args) {
        // capture the raw buffer
        args.requestBuffer = buffer; // verify version is appropriate

        if (args.ver !== _constants.RFC_1929_VERSION) {
          return end(_constants.RFC_1929_REPLIES.GENERAL_FAILURE, args);
        }

        authDomain.on('error', function (err) {
          // emit failed authentication event
          self.server.emit(EVENTS.AUTHENTICATION_ERROR, args.uname.toString(), err); // respond with auth failure

          return end(_constants.RFC_1929_REPLIES.GENERAL_FAILURE, args);
        }); // perform authentication

        self.options.authenticate(args.uname.toString(), args.passwd.toString(), socket, authDomain.intercept(function () {
          // emit successful authentication event
          self.server.emit(EVENTS.AUTHENTICATION, args.uname.toString()); // respond with success...

          var responseBuffer = Buffer.allocUnsafe(2);
          responseBuffer[0] = _constants.RFC_1929_VERSION;
          responseBuffer[1] = _constants.RFC_1929_REPLIES.SUCCEEDED; // respond then listen for cmd and dst info

          socket.write(responseBuffer, function () {
            // now listen for more details
            socket.once('data', connect);
          });
        }));
      });
    }
    /**
     * +----+-----+-------+------+----------+----------+
     * |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
     * +----+-----+-------+------+----------+----------+
     * | 1  |  1  | X'00' |  1   | Variable |    2     |
     * +----+-----+-------+------+----------+----------+
     *
     * @param {Buffer} buffer - a buffer
     * @returns {undefined}
     **/


    function connect(buffer) {
      var binaryStream = _binary["default"].stream(buffer);

      binaryStream.word8('ver').word8('cmd').word8('rsv').word8('atyp').tap(function (args) {
        // capture the raw buffer
        args.requestBuffer = buffer; // verify version is appropriate

        if (args.ver !== _constants.RFC_1928_VERSION) {
          return end(_constants.RFC_1928_REPLIES.GENERAL_FAILURE, args);
        } // append socket to active sessions


        self.activeSessions.push(socket); // create dst

        args.dst = {}; // ipv4

        if (args.atyp === _constants.RFC_1928_ATYP.IPV4) {
          binaryStream.buffer('addr.buf', LENGTH_RFC_1928_ATYP).tap(function (args) {
            args.dst.addr = [].slice.call(args.addr.buf).join('.');
          }); // domain name
        } else if (args.atyp === _constants.RFC_1928_ATYP.DOMAINNAME) {
          binaryStream.word8('addr.size').buffer('addr.buf', 'addr.size').tap(function (args) {
            args.dst.addr = args.addr.buf.toString();
          }); // ipv6
        } else if (args.atyp === _constants.RFC_1928_ATYP.IPV6) {
          binaryStream.word32be('addr.a').word32be('addr.b').word32be('addr.c').word32be('addr.d').tap(function (args) {
            args.dst.addr = []; // extract the parts of the ipv6 address

            ['a', 'b', 'c', 'd'].forEach(function (x) {
              x = args.addr[x]; // convert DWORD to two WORD values and append

              /* eslint no-magic-numbers : 0 */

              args.dst.addr.push(((x & 0xffff0000) >> 16).toString(16));
              args.dst.addr.push((x & 0xffff).toString(16));
            }); // format ipv6 address as string

            args.dst.addr = args.dst.addr.join(':');
          }); // unsupported address type
        } else {
          return end(_constants.RFC_1928_REPLIES.ADDRESS_TYPE_NOT_SUPPORTED, args);
        }
      }).word16bu('dst.port').tap(function (args) {
        if (args.cmd === _constants.RFC_1928_COMMANDS.CONNECT) {
          var connectionFilter = self.options.connectionFilter,
              connectionFilterDomain = _domain["default"].create(); // if no connection filter is provided, stub one


          if (!connectionFilter || typeof connectionFilter !== 'function') {
            connectionFilter = function connectionFilter(destination, origin, callback) {
              return setImmediate(callback);
            };
          } // capture connection filter errors


          connectionFilterDomain.on('error', function (err) {
            // emit failed destination connection event
            self.server.emit(EVENTS.CONNECTION_FILTER, // destination
            {
              address: args.dst.addr,
              port: args.dst.port
            }, // origin
            {
              address: socket.remoteAddress,
              port: socket.remotePort
            }, err); // respond with failure

            return end(_constants.RFC_1929_REPLIES.CONNECTION_NOT_ALLOWED, args);
          }); // perform connection

          return connectionFilter( // destination
          {
            address: args.dst.addr,
            port: args.dst.port
          }, // origin
          {
            address: socket.remoteAddress,
            port: socket.remotePort
          }, connectionFilterDomain.intercept(function () {
            var destination = _net["default"].createConnection(args.dst.port, args.dst.addr, function () {
              // prepare a success response
              var responseBuffer = Buffer.alloc(args.requestBuffer.length);
              args.requestBuffer.copy(responseBuffer);
              responseBuffer[1] = _constants.RFC_1928_REPLIES.SUCCEEDED; // write acknowledgement to client...

              socket.write(responseBuffer, function () {
                // listen for data bi-directionally
                destination.pipe(socket);
                socket.pipe(destination);
              });
            }),
                destinationInfo = {
              address: args.dst.addr,
              port: args.dst.port
            },
                originInfo = {
              address: socket.remoteAddress,
              port: socket.remotePort
            }; // capture successful connection


            destination.on('connect', function () {
              // emit connection event
              self.server.emit(EVENTS.PROXY_CONNECT, destinationInfo, destination); // capture and emit proxied connection data

              destination.on('data', function (data) {
                self.server.emit(EVENTS.PROXY_DATA, data);
              }); // capture close of destination and emit pending disconnect
              // note: this event is only emitted once the destination socket is fully closed

              destination.on('close', function (hadError) {
                // indicate client connection end
                self.server.emit(EVENTS.PROXY_DISCONNECT, originInfo, destinationInfo, hadError);
              });
              connectionFilterDomain.exit();
            }); // capture connection errors and response appropriately

            destination.on('error', function (err) {
              // exit the connection filter domain
              connectionFilterDomain.exit(); // notify of connection error

              err.addr = args.dst.addr;
              err.atyp = args.atyp;
              err.port = args.dst.port;
              self.server.emit(EVENTS.PROXY_ERROR, err);

              if (err.code && err.code === 'EADDRNOTAVAIL') {
                return end(_constants.RFC_1928_REPLIES.HOST_UNREACHABLE, args);
              }

              if (err.code && err.code === 'ECONNREFUSED') {
                return end(_constants.RFC_1928_REPLIES.CONNECTION_REFUSED, args);
              }

              return end(_constants.RFC_1928_REPLIES.NETWORK_UNREACHABLE, args);
            });
          }));
        } else {
          // bind and udp associate commands
          return end(_constants.RFC_1928_REPLIES.SUCCEEDED, args);
        }
      });
    }
    /**
     * +----+-----+-------+------+----------+----------+
     * |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
     * +----+-----+-------+------+----------+----------+
     * | 1  |  1  | X'00' |  1   | Variable |    2     |
     * +----+-----+-------+------+----------+----------+
     *
     * @param {Buffer} response - a buffer representing the response
     * @param {object} args - arguments to supply to the proxy end event
     * @returns {undefined}
     **/


    function end(response, args) {
      // either use the raw buffer (if available) or create a new one
      var responseBuffer = args.requestBuffer || Buffer.allocUnsafe(2);

      if (!args.requestBuffer) {
        responseBuffer[0] = _constants.RFC_1928_VERSION;
      }

      responseBuffer[1] = response; // respond then end the connection

      try {
        socket.end(responseBuffer);
      } catch (ex) {
        socket.destroy();
      } // indicate end of connection


      self.server.emit(EVENTS.PROXY_END, response, args);
    }
    /**
     * +----+----------+----------+
     * |VER | NMETHODS | METHODS  |
     * +----+----------+----------+
     * | 1  |    1     | 1 to 255 |
     * +----+----------+----------+
     *
     * @param {Buffer} buffer - a buffer
     * @returns {undefined}
     **/


    function handshake(buffer) {
      _binary["default"].stream(buffer).word8('ver').word8('nmethods').buffer('methods', 'nmethods').tap(function (args) {
        // verify version is appropriate
        if (args.ver !== _constants.RFC_1928_VERSION) {
          return end(_constants.RFC_1928_REPLIES.GENERAL_FAILURE, args);
        } // convert methods buffer to an array


        var acceptedMethods = [].slice.call(args.methods).reduce(function (methods, method) {
          methods[method] = true;
          return methods;
        }, {}),
            basicAuth = typeof self.options.authenticate === 'function',
            next = connect,
            noAuth = !basicAuth && typeof acceptedMethods[0] !== 'undefined' && acceptedMethods[0],
            responseBuffer = Buffer.allocUnsafe(2); // form response Buffer

        responseBuffer[0] = _constants.RFC_1928_VERSION;
        responseBuffer[1] = _constants.RFC_1928_METHODS.NO_AUTHENTICATION_REQUIRED; // check for basic auth configuration

        if (basicAuth) {
          responseBuffer[1] = _constants.RFC_1928_METHODS.BASIC_AUTHENTICATION;
          next = authenticate; // if NO AUTHENTICATION REQUIRED and
        } else if (!basicAuth && noAuth) {
          responseBuffer[1] = _constants.RFC_1928_METHODS.NO_AUTHENTICATION_REQUIRED;
          next = connect; // basic auth callback not provided and no auth is not supported
        } else {
          return end(_constants.RFC_1928_METHODS.NO_ACCEPTABLE_METHODS, args);
        } // respond then listen for cmd and dst info


        socket.write(responseBuffer, function () {
          // emit handshake event
          self.server.emit(EVENTS.HANDSHAKE, socket); // now listen for more details

          socket.once('data', next);
        });
      });
    } // capture the client handshake


    socket.once('data', handshake); // capture socket closure

    socket.once('end', function () {
      // remove the session from currently the active sessions list
      self.activeSessions.splice(self.activeSessions.indexOf(socket), 1);
    });
  });
};

exports.createServer = function (options) {
  var socksServer = new SocksServer(options);
  return socksServer.server;
};

exports.events = EVENTS;
exports.SocksServer = SocksServer;
//# sourceMappingURL=socks5.js.map
